
### 📚 Index
- **🧠 [CPU 구성](#cpu-구성-요소)**
- **🧾 [명령어](#명령어)**
- **🗄️ [캐시](#캐시-기억-장치)**
- **🚨 [인터럽트](#cpu-성능-향상-기법-1-인터럽트)**
- **🏭 [파이프라이닝](#cpu-성능-향상-기법-2-명령어-파이프라이닝)**
- **⚡️ [슈퍼스칼라](#cpu-성능-향상-기법-3-슈퍼스칼라-프로세서)**

<br>
<br>
<br>

### CPU 구성 요소
**❓CPU(중앙처리장치)는 어떤 요소들로 구성되어 있나요?**  

CPU는 프로그램 명령을 해석하고 수행하는 역할을 하는 컴퓨터의 두뇌로, ARU, 제어장치, 레지스터로 구성됩니다.  
ARU는 사칙연산 등의 산술 연산과 AND, OR 등의 논리 연산을 수행합니다. 제어장치는 명령어 해독과 데이터 흐름을 관리하며 레지스터는 현재 처리중인 데이터를 임시로 저장하는 저장장치 역할을 수행합니다.  
 <br><br>
 

**❓프로그램 카운터란 무엇인가요?** 

프로그램 카운터는 cpu 내부에 존재하는 레지스터로 다음에 실행할 명령어의 주소를 저장합니다.  
일반적으로 PC값은 다음 명령어 주소로 증가합니다. 하지만 조건문, 반복문 같은 분기 명령으로 인해 제어 흐름이 변경되는 경우 분기 대상이 되는 명령어의 주소로 갱신됩니다. <br><br> 

**❓분기(branch) 명령이 실행될 때 프로그램 카운터는 어떻게 변하나요?**

분기 명령이 실행되면, 조건이 참인 경우 프로그램 카운터는 분기할 주소로 갱신되고, 거짓인 경우 다음 순차 명령어 주소로 증가합니다.  
**분기 명령: cpu의 실행 흐름을 바꾸는 명령어 (조건문, 반복문, 인터럽트 호출 등)*  <br><br> 

**❓파이프라인에서 프로그램 카운터의 역할은 어떻게 달라지나요?** 

비파이프라인 CPU에서는 하나의 명령어가 완전히 끝난 뒤 PC가 갱신되지만, 파이프라인에서는 매 클럭마다 인출 단계에서 PC를 증가시켜 새 명령어를 가져옵니다. 즉 이전 명령어가 아직 실행/저장 단계에 있는 동안에도 PC는 이미 다음 명령어를 가리킵니다.  <br><br> 


**❓프로그램 카운터와 스택 포인터의 차이는 무엇인가요?** 

프로그램 카운터는 다음에 실행할 명령어의 주소를 저장하는 레지스터로 프로그램 실행 흐름을 관리합니다. 반면 스택 포인터는 메모리 스택의 최상단 위치를 가리키며 함수 호출과 반환 과정에서 스택의 사용 위치를 추적하는 역할을 합니다.  
**스택은 높은 주소부터 사용하고 힙은 낮은 주소부터 사용하여 메모리 충돌을 피하고 설계를 쉽게함* <br><br><br> 

---


### 명령어 

**❓명령어의 형태를 간단히 설명해주세요** 

명령어는 보통 연산코드와 피연산자로 구성되고, 필요하면 주소 지정 방식 정보가 함께 포함됩니다.  
연산코드는 어떤 연산을 수행할지를 나타내고 피연산자는 연산에 필요한 값 혹은 그 값의 위치를 나타내며, 주소 지정 방식은 피연산자가 어디에 있고 어떻게 가져올지를 결정합니다.  <br><br> 

**❓CPU가 명령어를 처리하는 명령어 사이클에 대해 자세히 설명해주세요**  

CPU는 프로그램이 실행될 때 메모리에 저장된 명령어를 인출, 해독, 실행의 과정을 거치며 실행합니다.  
인출 단계에서는 '기억장치 주소 레지스터(MAR)'에 프로그램 카운터 값을 복사하여 다음에 읽어올 데이터의 주소를 지정합니다. 프로그램 카운터는 이후 다음 명령어를 가리킬 수 있게 자동으로 값이 증가합니다. 주기억장치에서 읽어온 데이터는 '기억장치 버퍼 레지스터(MBR)'에 임시 저장되고 이 데이터를 '명령어 레지스터'에 전달합니다.  
명령어 해독 단계에서는 '명령어 레지스터'에 저장된 명령어를 '명령어 해독기'가 해독하여 수행할 작업을 분석하고 제어 신호를 생성합니다.  
명령어 실행 단계에서는 명령어의 종류에 따라 '연산 장치(ARU)'를 통해 연산을 수행하거나 데이터의 입출력 또는 메모리 접근 등의 작업이 이루어집니다. 연산 결과는 레지스터 또는 주기억장치에 저장합니다. 
<br><br>

**❓명령어 형식에 따라 실행속도나 메모리 사용이 어떻게 달라지나요?**

가변 길이·복잡한 형식(CISC 성향)은 한 명령어에 더 많은 동작을 담을 수 있어 명령어 개수가 줄고 메모리 사용이 줄 수 있습니다. 하지만 한  명령어가 여러 마이크로 동작으로 나뉘어 실행하는데 여러 사이클이 걸릴 수 있어 파이프라이닝이 불리해질 수 있습니다.  
고정 길이·단순한 형식(RISC 성향)은 실행 속도가 빠르고 실행시간이 대부분 일정하여 파이프라이닝에 유리합니다. 대신, 같은 일을 여러 명령어로 쪼개는 경우가 많아 코드 크기가 커질 수 있습니다.  <br><br> 


**❓주소 지정 방식의 종류를 예를 들어 설명해주세요** 

주소 지정 방식에는 즉시, 직접, 간접, 레지스터 주소 지정이 있습니다.  
예를 들어 피연산자 필드가 A일 때, 직접 주소 지정은 A를 실제 데이터가 있는 메모리 주소로 해석해 A번지에 접근해서 값을 가져옵니다. 간접 주소 지정은 A번지에 데이터가 아니라 또 다른 주소 B가 들어 있어 B번지를 한 번 더 따라가 값을 가져옵니다.  
즉시 주소 지정은 A가 주소가 아니라 상수 값 자체이고, 레지스터 주소 지정은 A가 레지스터 번호라서 해당 레지스터 값이 피연산자가 됩니다. 일반적으로 즉시/레지스터는 메모리 접근이 적어 빠르고, 간접은 유연하지만 메모리 접근이 늘어 느릴 수 있습니다. <br><br> 


**❓ RISC와 CISC 명령어 구조의 차이는 무엇인가요?**

RISC는 명령어가 고정 길이이고 단순하여 실행속도가 빠르고, 명령어마다 실행 시간이 대부분  일정합니다. <br>
반면 CISC는 명령어가 가변 길이이고 복잡하여 명령어마다 실행 시간에 차이가 있고, 이로 인해 파이프라이닝이 어렵다는 단점이 있습니다. 하지만 하나의 명령어가 여러 일을 수행하여 메모리를 절약할 수 있습니다. <br><br><br><br>

---

### 캐시 기억 장치 

**❓캐시 기억 장치가 필요한 이유가 무엇인가요?**

CPU는 내부 저장 장치로 레지스터를 사용하지만, 주기억 장치의 속도가 상대적으로 느려 속도 차이가 발생합니다. 이에 주기억 장치보다 빠른 캐시 기억 장치가 등장하게 되었습니다. 캐시는 CPU와 주기억 장치 사이에 위치하고, 지역성의 원리에 따라 자주 접근하는 데이터를 미리 가져와 저장합니다. CPU는 캐시를 먼저 탐색하고 없을때만 주기억 장치에 접근하기 때문에 작업 속도가 크게 향상합니다.  

 <br>

**❓시간 지역성과 공간 지역성을 각각 예로 설명해주세요**

시간 지역성은 최근에 접근한 데이터나 명령어를 다시 접근할 가능성이 높다는 원리입니다. 예를 들어 for문에서 루프 조건을 확인할때 i값처럼 매번 같은 변수를 읽고 갱신합니다. 방금 썼던걸 곧바로 또 쓰는 이런 패턴이 시간 지역성이 높다고 할 수 있습니다.
공간 지역성은 한 번 접근한 메모리 주소 주변의 데이터도 곧 접근할 가능성이 높다는 원리입니다. 대표적으로 배열을 순차 탐색하면 인접한 메모리 위치를 연속해서 읽게 되어 공간 지역성이 높습니다.  

<br>

**❓캐시 미스가 발생하면 어떤 일이 일어나나요?**

캐시 미스가 발생하면 CPU가 원하는 데이터를 찾지 못했기 때문에 더 아래 계층인 L2, L3 캐시, 메인 메모리로 순서로 내려가면서 데이터를 탐색합니다. 하위 계층에서 찾은 데이터는 상위 캐시에 복사되어 재사용 효율을 높입니다.  

<br>

**❓캐시 일관성 (Cache Coherency) 문제란 무엇인가요?**

캐시 일관성 문제는 멀티코어 환경에서 각 코어가 독립적인 캐시를 가질때, 한 코어가 특정 메모리 값을 수정하면 다른 코어의 캐시에는 여전히 이전 값이 남아있어 발생하는 불일치 문제입니다. 예를 들어 코어 1이 변수 x를 1에서 10으로 수정했는데 코어 2의 캐시에는 여전히 x가 1로 남아있는 상황이 발생할 수 있습니다.
이를 해결하기 위해 MESI같은 캐시 일관성 프로토콜을 사용하여 한 코어에서 데이터가 변경되면 다른 코어의 캐시를 무효화하거나 업데이트 합니다.  
<br>

*_MESI: 캐시 라인 상태 프로토콜_
*_캐시라인 : 메모리와 캐시 사이의 데이터가 이동하는 기본 단위_

_각 코어 캐시는 저장된 캐시 라인(보통 64byte)마다 상태를 붙여 누가 최신값을 가지는지, 다른 캐시는 무효인지 등을 관리함_


_M (Modified): 이 코어 캐시에만 최신값이 있고 수정됨. 메모리에 반영 아직 안됨_
_E (Exclusive): 이 코어 캐시에만 있고 메모리와 값이 같음_
_S (Shared): 여러 코어 캐시에 같은 값이 있을 수 있고 메모리와도 같음_
_I (Invalid): 이 캐시 라인은 무효. 데이터가 없거나, 다른 코어가 업데이트 해서 버려진 상태_ 
<br><br><br>

---

### CPU 성능 향상 기법 1. 인터럽트

**❓인터럽트란 무엇인가요?** 

CPU가 현재 실행중인 작업을 잠시 멈추고 중요한 이벤트를 먼저 처리할 수 있게 해주는 메커니즘입니다.   
인터럽트에는 키보드나 마우스 입력, 네트워크 패킷 도착같은 하드웨어 인터럽트가 있고, 시스템콜이나 예외같은 소프트웨어 인터럽트가 있습니다.  보통 인터럽트라고 하면 하드웨어 인터럽트를 가리킵니다.<br><br><br>

**❓인터럽트가 발생하면 CPU는 어떤 과정을 거치나요?**

인터럽트가 발생하면 CPU는 현재 실행 중인 명령어를 완료한 후, 프로그램 카운터와 레지스터 값 등의 컨텍스트를 스택이나 메모리에 저장합니다. 그 다음 인터럽트 벡터 테이블을 참조해서 해당 인터럽트를 처리할 인터럽트 서비스 루틴(ISR) 주소를 찾아 실행합니다. 인터럽트 처리가 완료되면 저장해뒀던 컨텍스트를 복원하고 원래 작업을 이어서 수행합니다. <br><br><br>

**❓인터럽트 우선순위가 필요한 이유는 무엇인가요?**

여러 인터럽트가 동시에 발생했을 때 더 긴급하고 중요한 인터럽트를 먼저 처리하기 위해서입니다.<br>
시스템에서는 여러 종류의 인터럽트가 동시에 발생할 수 있습니다. 예를 들어 전원 오류와 키보드 입력이 동시에 발생한다면, 당연히 전원 오류를 먼저 처리해야 데이터 손실을 막을 수 있습니다. 이처럼 인터럽트마다 중요도와 긴급도가 다르기 때문에 우선순위를 부여해서 높은 순위의 인터럽트가 낮은 순위의 인터럽트를 선점할 수 있게 합니다. 

*높은 우선순위 (긴급): 전원 장애, 하드웨어 오류,타이머 인터럽트*<br>
*중간 우선순위: 디스크 I/O 완료, 네트워크 패킷 도착*<br>
*낮은 우선순위: 키보드 입력, 마우스 이동*<br><br><br>

**❓폴링(Poling) 방식과 인터럽트 방식의 차이는 무엇인가요?**

폴링은 CPU가 주기적으로 디바이스 상태를 확인하는 것이고, 인터럽트는 디바이스가 필요할 때 CPU에게 신호를 보내는 방식입니다. 폴링은 간단하고 예측 가능하지만 CPU를 계속 사용해 비효율적입니다. 반면 인터럽트는 효율적이고 이벤트를 바로 처리할 수 있지만 인터럽트 처리 오버헤드가 있습니다. 

**한 프로세스 내에서 실행 흐름이 바뀌는 것이고, 다른 프로세스로 처리하는게 아니라서 컨텍스트 스위칭이 아님* <br><br><br><br>

---

### CPU 성능 향상 기법 2. 명령어 파이프라이닝

  

**❓명령어 파이프라이닝이 무엇인가요?**

명령어를 동시에 처리하기 위해 명령어 실행 단계를 여러 단계로 나누고, 각 단계를 병렬로 실행하는 CPU 성능 향상 기법입니다. 각 단계에 소요되는 시간이 명령어마다 동일하지 않으면 파이프라이닝에 의한 속도 향상을 기대할 수 없기 때문에 파이프라인의 단계 수를 증가시켜 각 단계 처리 시간을 같게 해야 합니다. 파이프라이닝 단계 수를 K라고 했을때 이상적인 상황에서 K배의 속도 향상을 기대할 수 있습니다. 

**2단계 파이프라이닝: 인출 - 실행* <br>
**4단계 파이프라이닝: 인출 - 해독, 오퍼랜드 인출, 실행* <br>
**6단계 파이프라이닝: 인출 - 해독, 오퍼랜드 계산, 오퍼랜드 인출, 실행, 오퍼랜드 저장* <br><br><br>

**❓파이프라인 해저드에는 어떤 종류가 있나요?**

파이프라인 해저드에는 구조적 해저드, 데이터 해저드, 제어 해저드 3가지가 있습니다. <br>
구조적 해저드는 여러 명령이 동시에 같은 하드웨어 자원을 사용하려 할 때, 데이터 해저드는 이전 명령의 결과를 다음 명령이 바로 사용하려 할 때, 제어 해저드는 분기 명령으로 인해 다음 실행할 명령을 확정할 수 없을 때 발생합니다.<br><br><br>

**❓해저드를 해결하는 방법은 무엇인가요?**

구조적 해저드는 하드웨어 자원을 추가하거나 잠시 파이프라인을 멈추고 순차 실행하여 해결합니다.
데이터 해저드도 파이프라인을 대기하거나 포워딩으로 결과를 저장없이 바로 다음 명령으로 전달하여 해결합니다.
제어 해저드는 분기 예측을 통해 다음 명령을 미리 인출하여 해결합니다. <br><br><br>

 

**❓슈퍼스칼라와 파이프라인의 차이는 무엇인가요?**

파이프라인은 한 사이클에 명령어 하나씩 처리하고, 슈퍼스칼라는 여러 실행 유닛을 두어 한 사이클에 여러 명령어를 동시에 처리합니다.<br><br><br><br>

---



### CPU 성능 향상 기법 3. 슈퍼스칼라 프로세서

**❓슈퍼스칼라 프로세서가 무엇인가요?**

슈퍼스칼라 프로세서는 여러 실행 유닛을 두어 한 사이클에 여러 명령어를 동시에 처리하는 프로세서입니다. <br><br><br>

**❓여러 명령을 동시에 실행하기 위해 필요한 CPU 조건은?**

여러 명령어를 동시에 실행하려면 다수의 실행 유닛, 동시 인출/디코드가 가능한 구조가 필요합니다. 또한 명령어 간 의존성을 판별하는 하드웨어인데, 이를 위해 레지스터 리네이밍, 비순차 실행(Out-of-Order Execution) 등의 기법이 함께 사용됩니다.

*레지스터 리네이밍: 가짜 의존성(WAR/WAW)을 없애서 동시에 실행 가능한 폭을 늘림 (진짜 의존성: RAW)  
비순차 실행: 느린 명령어(예: load miss) 때문에 전체가 멈추는 걸 막고, 준비된 작업을 먼저 실행해서 유휴 시간을 줄임*
<br><br><br>


**❓슈퍼파이프라인과의 차이는 무엇인가요?**

슈퍼파이프라인은 파이프라인 단계를 더 잘게 쪼개 클럭 속도를 높이는 기법이고, 슈퍼스칼라는 파이프라인 자체를 여러 개 두어 한 사이클에 2개 이상의 명령어를 동시에 처리하는 기법입니다. 즉 슈퍼파이프라인은 깊이(depth) 를 늘리는 방식이고, 슈퍼스칼라는 폭(width) 을 늘리는 방식입니다. 현대 CPU는 이 두 기법을 함께 사용하여 성능을 극대화합니다. 
<br><br><br>

**❓슈퍼스칼라 구조의 성능 향상이 제한되는 이유는 무엇인가요?**

이론적으로 실행 유닛을 늘리면 성능이 비례해서 올라야 하지만, 실제 프로그램에는 명령어 간 데이터 의존성이나 분기 명령에 의한 제어 의존성때문에 동시에 실행 가능한 명령어 수가 제한됩니다. 또한 실행 유닛이 늘어날수록 의존성 검출·스케줄링 하드웨어의 복잡도가 급격히 증가하여 클럭 속도에도 악영향을 줍니다. 이러한 이유 때문에 현대 CPU는 보통 4~6등급 슈퍼스칼라를 사용합니다.
<br><br><br>
