**❓프로그램 카운터란 무엇인가요?** 

프로그램 카운터는 cpu 내부에 존재하는 레지스터로 다음에 실행할 명령어의 주소를 저장합니다.  
일반적으로 PC값은 다음 명령어 주소로 증가합니다. 하지만 조건문, 반복문 같은 분기 명령으로 인해 제어 흐름이 변경되는 경우 분기 대상이 되는 명령어의 주소로 갱신됩니다. <br><br> 

**❓분기(branch) 명령이 실행될 때 프로그램 카운터는 어떻게 변하나요?**

분기 명령이 실행되면, 조건이 참인 경우 프로그램 카운터는 분기할 주소로 갱신되고, 거짓인 경우 다음 순차 명령어 주소로 증가합니다.  
**분기 명령: cpu의 실행 흐름을 바꾸는 명령어 (조건문, 반복문, 인터럽트 호출 등)*  <br><br> 

**❓파이프라인에서 프로그램 카운터의 역할은 어떻게 달라지나요..?** 

모르겟어요  <br><br> 


**❓프로그램 카운터와 스택 포인터의 차이는 무엇인가요?** 

프로그램 카운터는 다음에 실행할 명령어의 주소를 저장하는 레지스터로 프로그램 실행 흐름을 관리합니다. 반면 스택 포인터는 메모리 스택의 최상단 위치를 가리키며 함수 호출과 반환 과정에서 스택의 사용 위치를 추적하는 역할을 합니다.  
**스택은 높은 주소부터 사용하고 힙은 낮은 주소부터 사용하여 메모리 충돌을 피하고 설계를 쉽게함* <br><br> 


**❓명령어의 형태를 간단히 설명해주세요** 

명령어는 보통 연산코드와 피연산자로 구성되고, 필요하면 주소 지정 방식 정보가 함께 포함됩니다.  
연산코드는 어떤 연산을 수행할지를 나타내고 피연산자는 연산에 필요한 값 혹은 그 값의 위치를 나타내며, 주소 지정 방식은 피연산자가 어디에 있고 어떻게 가져올지를 결정합니다.  <br><br> 


**❓명령어 형식에 따라 실행속도나 메모리 사용이 어떻게 달라지나요?**

가변 길이·복잡한 형식(CISC 성향)은 한 명령어에 더 많은 동작을 담을 수 있어 명령어 개수가 줄고 메모리 사용이 줄 수 있습니다. 하지만 한  명령어가 여러 마이크로 동작으로 나뉘어 실행하는데 여러 사이클이 걸릴 수 있어 파이프라이닝이 불리해질 수 있습니다.  
고정 길이·단순한 형식(RISC 성향)은 실행 속도가 빠르고 실행시간이 대부분 일정하여 파이프라이닝에 유리합니다. 대신, 같은 일을 여러 명령어로 쪼개는 경우가 많아 코드 크기가 커질 수 있습니다.  <br><br> 


**❓주소 지정 방식의 종류를 예를 들어 설명해주세요** 

주소 지정 방식에는 즉시, 직접, 간접, 레지스터 주소 지정이 있습니다.  
예를 들어 피연산자 필드가 A일 때, 직접 주소 지정은 A를 실제 데이터가 있는 메모리 주소로 해석해 A번지에 접근해서 값을 가져옵니다. 간접 주소 지정은 A번지에 데이터가 아니라 또 다른 주소 B가 들어 있어 B번지를 한 번 더 따라가 값을 가져옵니다.  
즉시 주소 지정은 A가 주소가 아니라 상수 값 자체이고, 레지스터 주소 지정은 A가 레지스터 번호라서 해당 레지스터 값이 피연산자가 됩니다. 일반적으로 즉시/레지스터는 메모리 접근이 적어 빠르고, 간접은 유연하지만 메모리 접근이 늘어 느릴 수 있습니다. <br><br> 


**❓ RISC와 CISC 명령어 구조의 차이는 무엇인가요?**

RISC는 명령어가 고정 길이이고 단순하여 실행속도가 빠르고, 명령어마다 실행 시간이 대부분  일정합니다. <br>
반면 CISC는 명령어가 가변 길이이고 복잡하여 명령어마다 실행 시간에 차이가 있고, 이로 인해 파이프라이닝이 어렵다는 단점이 있습니다. 하지만 하나의 명령어가 여러 일을 수행하여 메모리를 절약할 수 있습니다. <br><br> 

#### 캐시 기억 장치 

**❓캐시 기억 장치가 필요한 이유가 무엇인가요?**

CPU는 내부 저장 장치로 레지스터를 사용하지만, 주기억 장치의 속도가 상대적으로 느려 속도 차이가 발생합니다. 이에 주기억 장치보다 빠른 캐시 기억 장치가 등장하게 되었습니다. 캐시는 CPU와 주기억 장치 사이에 위치하고, 지역성의 원리에 따라 자주 접근하는 데이터를 미리 가져와 저장합니다. CPU는 캐시를 먼저 탐색하고 없을때만 주기억 장치에 접근하기 때문에 작업 속도가 크게 향상합니다.  

 <br>

**❓시간 지역성과 공간 지역성을 각각 예로 설명해주세요**

시간 지역성은 최근에 접근한 데이터나 명령어를 다시 접근할 가능성이 높다는 원리입니다. 예를 들어 for문에서 루프 조건을 확인할때 i값처럼 매번 같은 변수를 읽고 갱신합니다. 방금 썼던걸 곧바로 또 쓰는 이런 패턴이 시간 지역성이 높다고 할 수 있습니다.
공간 지역성은 한 번 접근한 메모리 주소 주변의 데이터도 곧 접근할 가능성이 높다는 원리입니다. 대표적으로 배열을 순차 탐색하면 인접한 메모리 위치를 연속해서 읽게 되어 공간 지역성이 높습니다.  

<br>

**❓캐시 미스가 발생하면 어떤 일이 일어나나요?**

캐시 미스가 발생하면 CPU가 원하는 데이터를 찾지 못했기 때문에 더 아래 계층인 L2, L3 캐시, 메인 메모리로 순서로 내려가면서 데이터를 탐색합니다. 하위 계층에서 찾은 데이터는 상위 캐시에 복사되어 재사용 효율을 높입니다.  

<br>

**❓캐시 일관성 (Cache Coherency) 문제란 무엇인가요?**

캐시 일관성 문제는 멀티코어 환경에서 각 코어가 독립적인 캐시를 가질때, 한 코어가 특정 메모리 값을 수정하면 다른 코어의 캐시에는 여전히 이전 값이 남아있어 발생하는 불일치 문제입니다. 예를 들어 코어 1이 변수 x를 1에서 10으로 수정했는데 코어 2의 캐시에는 여전히 x가 1로 남아있는 상황이 발생할 수 있습니다.
이를 해결하기 위해 MESI같은 캐시 일관성 프로토콜을 사용하여 한 코어에서 데이터가 변경되면 다른 코어의 캐시를 무효화하거나 업데이트 합니다.  
<br>

*_MESI: 캐시 라인 상태 프로토콜_
*_캐시라인 : 메모리와 캐시 사이의 데이터가 이동하는 기본 단위_

_각 코어 캐시는 저장된 캐시 라인(보통 64byte)마다 상태를 붙여 누가 최신값을 가지는지, 다른 캐시는 무효인지 등을 관리함_


_M (Modified): 이 코어 캐시에만 최신값이 있고 수정됨. 메모리에 반영 아직 안됨_
_E (Exclusive): 이 코어 캐시에만 있고 메모리와 값이 같음_
_S (Shared): 여러 코어 캐시에 같은 값이 있을 수 있고 메모리와도 같음_
_I (Invalid): 이 캐시 라인은 무효. 데이터가 없거나, 다른 코어가 업데이트 해서 버려진 상태_